# Converting AI Agents from Chat to Task Execution

## The Problem
Your AI agents are currently functioning as chatbots instead of autonomous task executors. To make them actually perform tasks like managing emails, filling forms, or navigating websites, you need to implement a **Task Execution Pipeline** that converts natural language instructions into browser automation commands.

## Solution Architecture

### 1. Task Planning Layer
Create an AI planning system that breaks down user requests into executable steps:

```typescript
// server/task-planner.ts
interface TaskStep {
  id: string;
  action: string;
  target: string;
  parameters: Record<string, any>;
  dependencies?: string[];
}

interface TaskPlan {
  id: string;
  description: string;
  steps: TaskStep[];
  requiredPermissions: string[];
  estimatedDuration: number;
}

class TaskPlanner {
  async planTask(userRequest: string, context: any): Promise<TaskPlan> {
    // Use OpenAI to convert natural language to structured plan
    const prompt = `
    Convert this user request into a detailed task plan:
    "${userRequest}"
    
    Available capabilities:
    - navigate_to: Go to a specific URL
    - fill_form: Fill out form fields
    - click_element: Click buttons, links, etc.
    - extract_data: Get information from pages
    - wait: Pause execution
    - send_email: Compose and send emails
    
    Return a JSON plan with steps that can be executed sequentially.
    `;
    
    const response = await this.callOpenAI(prompt);
    return this.parseTaskPlan(response);
  }
}
```

### 2. Enhanced Command System
Extend your existing command system to handle complex task sequences:

```typescript
// server/task-executor.ts
interface ExecutionContext {
  userId: string;
  sessionId: string;
  currentUrl?: string;
  extractedData: Record<string, any>;
  variables: Record<string, any>;
}

class TaskExecutor {
  private context: ExecutionContext;
  
  async executeTask(plan: TaskPlan, userId: string): Promise<void> {
    this.context = { userId, sessionId: generateId(), extractedData: {}, variables: {} };
    
    for (const step of plan.steps) {
      try {
        await this.executeStep(step);
        await this.waitForCompletion(step.id);
      } catch (error) {
        await this.handleStepError(step, error);
      }
    }
  }
  
  private async executeStep(step: TaskStep): Promise<void> {
    switch (step.action) {
      case 'navigate_to':
        await this.sendBrowserCommand('navigate', { url: step.target });
        break;
        
      case 'fill_form':
        await this.sendBrowserCommand('fill_form', {
          selectors: step.parameters.selectors,
          values: this.resolveVariables(step.parameters.values)
        });
        break;
        
      case 'extract_data':
        const data = await this.sendBrowserCommand('extract_content', step.parameters);
        this.context.extractedData[step.id] = data;
        break;
        
      case 'smart_click':
        // Use AI to find the right element to click
        await this.intelligentElementClick(step.parameters.description);
        break;
    }
  }
}
```

### 3. Email Management Example
Here's how to implement the email management agent you mentioned:

```typescript
// agents/email-manager.ts
class EmailManagerAgent {
  async handleEmailTask(request: string, userId: string): Promise<void> {
    // Example: "Reply to all unread emails from customers about refunds"
    
    const plan = await this.taskPlanner.planTask(request, {
      domain: 'email',
      capabilities: ['gmail_access', 'compose', 'reply', 'classify']
    });
    
    // Generated plan might look like:
    const emailPlan: TaskPlan = {
      id: 'email-management-001',
      description: 'Reply to refund-related customer emails',
      steps: [
        {
          id: 'nav-gmail',
          action: 'navigate_to',
          target: 'https://mail.google.com',
          parameters: {}
        },
        {
          id: 'find-unread',
          action: 'click_element',
          target: '[aria-label="Unread"]',
          parameters: {}
        },
        {
          id: 'extract-emails',
          action: 'extract_data',
          target: '.email-list',
          parameters: {
            selectors: {
              sender: '.sender-name',
              subject: '.subject',
              preview: '.preview-text'
            }
          }
        },
        {
          id: 'process-emails',
          action: 'process_extracted_data',
          target: 'emails',
          parameters: {
            filter: 'refund-related',
            action: 'reply'
          }
        }
      ],
      requiredPermissions: ['gmail.readonly', 'gmail.compose'],
      estimatedDuration: 300
    };
    
    await this.taskExecutor.executeTask(emailPlan, userId);
  }
}
```

### 4. Intelligent Element Finding
Add AI-powered element detection to handle dynamic websites:

```typescript
// chrome-extension/intelligent-interaction.js
class IntelligentInteraction {
  async findElementByDescription(description, context = '') {
    // Get page elements and their context
    const elements = this.getAllInteractiveElements();
    
    // Send to your backend AI service
    const response = await fetch('/api/find-element', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        description,
        context,
        elements: elements.map(el => ({
          tag: el.tagName,
          text: el.innerText?.slice(0, 100),
          attributes: this.getRelevantAttributes(el),
          xpath: this.getXPath(el)
        }))
      })
    });
    
    const { selectedXPath } = await response.json();
    return document.evaluate(selectedXPath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
  }
  
  getAllInteractiveElements() {
    const selector = 'button, a, input, select, textarea, [onclick], [role="button"], [tabindex]';
    return Array.from(document.querySelectorAll(selector));
  }
}
```

### 5. Agent State Management
Implement proper state tracking for multi-step tasks:

```typescript
// server/agent-state.ts
interface AgentSession {
  id: string;
  userId: string;
  agentId: string;
  currentTask?: TaskPlan;
  executionState: 'idle' | 'planning' | 'executing' | 'paused' | 'completed' | 'error';
  currentStep?: number;
  context: ExecutionContext;
  history: AgentAction[];
}

class AgentStateManager {
  private sessions: Map<string, AgentSession> = new Map();
  
  async createSession(userId: string, agentId: string): Promise<string> {
    const session: AgentSession = {
      id: generateId(),
      userId,
      agentId,
      executionState: 'idle',
      context: { userId, sessionId: '', extractedData: {}, variables: {} },
      history: []
    };
    
    this.sessions.set(session.id, session);
    return session.id;
  }
  
  async pauseExecution(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.executionState = 'paused';
      await this.saveCheckpoint(session);
    }
  }
  
  async resumeExecution(sessionId: string): Promise<void> {
    const session = this.sessions.get(sessionId);
    if (session && session.currentTask) {
      session.executionState = 'executing';
      await this.continueTask(session);
    }
  }
}
```

### 6. Enhanced Chrome Extension
Update your extension to handle complex command sequences:

```javascript
// chrome-extension/background.js - Enhanced
class EnhancedCommandProcessor {
  constructor() {
    this.currentTask = null;
    this.executionQueue = [];
    this.isExecuting = false;
  }
  
  async processTaskSequence(commands) {
    this.currentTask = {
      id: commands.taskId,
      steps: commands.steps,
      currentStep: 0
    };
    
    this.isExecuting = true;
    
    for (let i = 0; i < commands.steps.length; i++) {
      this.currentTask.currentStep = i;
      const step = commands.steps[i];
      
      try {
        await this.executeStep(step);
        await this.reportStepCompletion(step.id);
      } catch (error) {
        await this.reportStepError(step.id, error);
        break;
      }
    }
    
    this.isExecuting = false;
    await this.reportTaskCompletion();
  }
  
  async executeStep(step) {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    
    switch (step.action) {
      case 'navigate_to':
        await chrome.tabs.update(tab.id, { url: step.parameters.url });
        await this.waitForPageLoad(tab.id);
        break;
        
      case 'intelligent_click':
        await chrome.scripting.executeScript({
          target: { tabId: tab.id },
          func: this.intelligentClickScript,
          args: [step.parameters.description]
        });
        break;
        
      case 'extract_and_process':
        const results = await chrome.scripting.executeScript({
          target: { tabId: tab.id },
          func: this.extractDataScript,
          args: [step.parameters]
        });
        
        // Send extracted data back to server for processing
        await this.sendDataToServer(step.id, results[0].result);
        break;
    }
  }
}
```

### 7. API Integration for External Services
Add support for external service integrations:

```typescript
// server/integrations/gmail-integration.ts
class GmailIntegration {
  private oauth2Client: OAuth2Client;
  
  async replyToEmail(emailId: string, replyContent: string, userId: string) {
    const auth = await this.getAuthForUser(userId);
    const gmail = google.gmail({ version: 'v1', auth });
    
    // Get original email
    const originalEmail = await gmail.users.messages.get({
      userId: 'me',
      id: emailId
    });
    
    // Compose reply
    const reply = await this.composeReply(originalEmail.data, replyContent);
    
    // Send reply
    return await gmail.users.messages.send({
      userId: 'me',
      requestBody: reply
    });
  }
  
  async generateReplyContent(originalEmail: any, context: string): Promise<string> {
    const prompt = `
    Generate a professional reply to this email:
    
    From: ${originalEmail.from}
    Subject: ${originalEmail.subject}
    Content: ${originalEmail.body}
    
    Context: ${context}
    
    Keep the reply concise and helpful.
    `;
    
    return await this.callOpenAI(prompt);
  }
}
```

## Implementation Steps

### Phase 1: Core Task Execution (Week 1-2)
1. Implement TaskPlanner class
2. Enhance your existing CommandSigner to handle task sequences
3. Update Chrome extension to process multi-step commands
4. Test with simple tasks (navigate + click + extract)

### Phase 2: Intelligent Interactions (Week 3-4)
1. Add AI-powered element finding
2. Implement smart form filling
3. Add error handling and recovery
4. Create agent state management

### Phase 3: Service Integrations (Week 5-6)
1. Gmail API integration
2. Calendar management
3. CRM system integrations
4. Advanced email processing

### Sample Agent Implementation
Here's a complete example for a customer service agent:

```typescript
// agents/customer-service-agent.ts
export class CustomerServiceAgent extends BaseAgent {
  async processRequest(request: string, userId: string): Promise<void> {
    // Instead of just chatting, create a task plan
    const plan = await this.planCustomerServiceTask(request);
    
    // Execute the plan
    await this.taskExecutor.executeTask(plan, userId);
  }
  
  private async planCustomerServiceTask(request: string): Promise<TaskPlan> {
    // Example: "Check all new support tickets and respond to urgent ones"
    
    if (request.includes('support tickets')) {
      return {
        id: 'support-ticket-management',
        description: 'Manage support tickets',
        steps: [
          {
            id: 'navigate-crm',
            action: 'navigate_to',
            target: 'https://your-crm.com/tickets',
            parameters: {}
          },
          {
            id: 'filter-urgent',
            action: 'click_element',
            target: '[data-filter="urgent"]',
            parameters: {}
          },
          {
            id: 'process-tickets',
            action: 'process_ticket_list',
            target: '.ticket-list',
            parameters: {
              maxTickets: 10,
              responseTemplate: 'professional_support'
            }
          }
        ],
        requiredPermissions: ['crm.read', 'crm.write'],
        estimatedDuration: 600
      };
    }
    
    // Add more task patterns...
  }
}
```

## Testing Your Implementation

1. **Start Simple**: Begin with single-step tasks (navigate to a page)
2. **Add Complexity**: Progress to multi-step workflows (navigate + extract + process)
3. **Test Error Handling**: Ensure agents can recover from failures
4. **Monitor Performance**: Track execution times and success rates

Your existing architecture is already well-suited for this enhancement. The main change is shifting from response generation to task execution, while maintaining the security model you've already built.